/*
File Name: hw4.cpp
Author: genhen
Date Created: 04/13/2014
Description: Uses Rationals to modify store and compute multiple
             outputs generated by rationals
Run: g++ -std=c++14 -o hw4.exe hw4.cpp && ./hw4.exe && rm hw4.exe
*/

#include <cmath>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/** @class Polynomial
	1. stores polynomials and their corresponding constants in a class using vectors
	2. has the ability to multiply the polynomials by a constant
	3. has the ability to take a derivative/transform the polynomial
	4. has a print function to display the polynomial
	5. can display the degree of the polynomial as well as the coefficient of a certain power of x
	6. can initialize with 0 or using a vector of integers)
*/
class Polynomial
{
    public:
        // Constructors
        Polynomial();
        Polynomial(const vector<int> &coeffs);
        
        // Accessors
        int Degree() const;
        int Coefficient(int k) const;
        void print() const;
        bool Is_The_Polynomial_All_Zeroes() const;
        
        // Mutators
        void constantMultiply(int x);
        void Transform();
        void constant_change(int element, int new_value);
        void add_element(int x);
        
        // Other
        double evaluateAt(double x);

        // Operator Functions
        Polynomial  operator++(int unused);
        Polynomial& operator++();
        Polynomial  operator--(int unused);
        Polynomial& operator--();
        Polynomial& operator+=(const Polynomial &poly_to_be_added);
        Polynomial& operator-=(const Polynomial &poly_to_be_subtracted);
        Polynomial& operator*=(const Polynomial &poly_to_be_multiplied);
        friend ostream& operator<<(ostream &outstream, const Polynomial &poly_out);
        friend istream& operator>>(istream &instream, Polynomial &poly_in);
    private:
        vector<int> coefficient;
};

/** @class Rational
	1. Is an inherited class that uses the Polynomial class to create
	   rationals, a kind of polynomial mix
	2. Can print the rational
	3. Can evaluate the rational at certain points/coefficients)
*/
class Rational
{
    public:
        // Constructors
        Rational();
        Rational(const Polynomial &p);
        Rational(const Polynomial &px, const Polynomial &qx);
		
	// Mutators
	void polynomial_Change(int qx_px, const Polynomial &poly_in);
        
        // Other
        double evaluateAt(double x);
        
        // Accessors
        void print() const;
        Polynomial return_px() const;
        Polynomial return_qx() const;
        
        // Operator Functions
        Rational operator++(int unused);
        Rational& operator++();
        Rational operator--(int unused);
        Rational& operator--();
        Rational& operator+=(const Rational &rational_to_be_added);
        Rational& operator-=(const Rational &rational_to_be_subtracted);
        Rational& operator*=(const Rational &rational_to_be_multiplied);
        Rational& operator/=(const Rational &rational_to_be_divided);
        friend ostream& operator<<(ostream &outstream, const Rational &rational1);
        friend istream& operator>>(istream &instream, Rational &rational1);
    private:
        Polynomial px_top,
	           qx_bottom;
};

//
// POLYNOMIAL CONSTRUCTORS
//
/**
	This default constructor creates a '0' polynomial by initializing the private integer vector 'coefficient'
	to have one value of 0
*/
Polynomial::Polynomial()
{
    coefficient.push_back(0);
}

/**
	This constructor creates a polynomial by initializing the private integer vector 'coefficient' using a for loop
	@param coeffs is a vector that is copied over to the private integer vector in this polynomial
*/
Polynomial::Polynomial(const vector<int> &coeffs)
{
	for(int counter = 0, number_of_terms = coeffs.size(); counter < number_of_terms; ++counter)
		coefficient.push_back(coeffs[counter]);
}


//
// POLYNOMIAL ACCESSORS
//
/**
	This function calculates the degree of a polynomial by analyzing the highest slot in the vector coefficient
	that is a non-zero integer and can be considered the highest degree
	@return returns the highest degree of x in the polynomial, with a constant or 0 being degree '0'
*/
int Polynomial::Degree() const
{
	int degree_of_polynomial = 0,
	    size_of_vector = coefficient.size();
	for(int counter = 0; counter < size_of_vector; counter++)
	{
		if(coefficient[counter] != 0)
			degree_of_polynomial = counter;
	}
	
	return degree_of_polynomial;
}

/**
	This function returns a certain integer from the integer vector 'coefficient' at the degree/slot specified
	by the user
	@return takes the specified coefficient from the vector and returns the int values
*/
int Polynomial::Coefficient(int k) const
{
    return coefficient[k];
}

/**
	The function prints the polynomial by checking powers (in order for weird cases like
	x^0 or x^1 not to be displayed), checking negatives (for displaying -'s), and checking
	the counter in a for loop (used to display each coefficient of the polynomial from the
	'coefficient' vector) in order to figure out if it is the first coefficient or not
*/
void Polynomial::print() const
{
	int number_of_terms = coefficient.size(),
	    first_term = 0;

	for(int i = 0; (first_term == 0) && (i < (number_of_terms + 1)); i++)
		if(coefficient[i] != 0)
			first_term = (i + 1);

	for(int counter = 0; counter < number_of_terms; counter++)
	{
		if(coefficient[counter] != 0)
		{
			if(counter == 0)
				cout << coefficient[counter];
			else if(counter == 1)
			{
				if((first_term - 1) != counter)
					cout << '+';

				if(coefficient[counter] == 1)
					cout << 'x';
			}
			else if(coefficient[counter] == -1)
				cout << '-' << 'x';
			else
				cout << coefficient[counter] << 'x';
		}
		else
		{
			if((first_term - 1) != counter)
				cout << '+';

			if(coefficient[counter] == 1)
				cout << 'x' << '^' << counter;
			else if(coefficient[counter] == -1)
				cout << '-' << 'x' << '^' << counter;
			else
				cout << coefficient[counter] << "x^" << counter;
		}
	}
        else if(coefficient[counter] == 0 && (counter == 0) && (Is_The_Polynomial_All_Zeroes() == true))
            cout << coefficient[counter];
    }
	return;
}

/**
	This function quickly loops through the private integer vector 'coefficient' in order to figure
	out if all of the coefficients are zero and stops/returns 0 if even one coefficient is 0
	@return depending on whether the vector is all 0's (true) or not (false), returns the appropriate bool value
*/
bool Polynomial::Is_The_Polynomial_All_Zeroes() const
{
    int number_of_terms = coefficient.size();
    bool polynomial_all_zeroes = true;
    for(int counter = 0; ((polynomial_all_zeroes == true) && (counter < number_of_terms)); counter++)
    {
        if(coefficient[counter] == 0)
        {
            polynomial_all_zeroes = true;
        }
        else
        {
            polynomial_all_zeroes = false;
        }
    }
    return polynomial_all_zeroes;
}


//
// POLYNOMIAL MUTATORS
//
/**
	This function loops through the 'coefficient' vector and multiplies by an integer specified
	by the user.
	@param takes an integer value in to multiply every coefficient int(integer) by
*/
void Polynomial::constantMultiply(int x)
{
    int number_of_terms = coefficient.size();
    for(int counter = 0; counter < number_of_terms; counter++)
    {
        coefficient[counter] = coefficient[counter] * x;
    }
	return;
}

/**
	This function transforms the polynomial by taking a derivative (aka multiplying by the
	power, lowering the power of each value, and setting the last coefficient (that would
	try to gather information from outside the range if included in the for loop) equal
	to zero(integer 0)
*/
void Polynomial::Transform()
{
    int number_of_terms = coefficient.size();
    for(int counter = 0; counter < (number_of_terms - 1); counter++)
    {
        coefficient[counter] = coefficient[counter + 1] * (counter + 1);
    }
    coefficient[number_of_terms - 1] = 0;
	return;
}

/**
	Modifies the integer/constant in the specified element slot
	in the coefficient array
	@param takes an element number from 0 to max_size from user,
           takes a new value to be assigned to that spot
*/
void Polynomial::constant_change(int element, int new_value)
{
    coefficient[element] = new_value;
    return;
}

/**
	Adds an element into polynomial coefficient vector
	@param integer to add into vector
*/
void Polynomial::add_element(int x)
{
	coefficient.push_back(x);

	return;
}


//
// POLYNOMIAL OTHER
//
/**
	Takes a double and plugs it into every x in the polynomial
	@param x is the value that will be entered into every x-value
	@return it adds up all the multiplications of coefficients
		    with values of x raised to the counter
*/
double Polynomial::evaluateAt(double x)
{
    int number_of_terms = coefficient.size();
    double evaluation_total = 0;

    for(int counter = 0; counter < number_of_terms; counter++)
        evaluation_total = evaluation_total + (coefficient[counter] * pow(x,counter));

    return evaluation_total;
}


//
// POLYNOMIAL MEMBER OPERATOR FUNCTIONS
//
/**
	This member function outputs a polynomial with strict rules regarding degree of each
	coefficient, negatives or positive, and analysis of existance of 1.
	@return (outstream) returns an ostream object that is filled with the correctly written polynomial
	@param (outstream)an ostream object (usually cout) that will collect all of the correct outputs
	@param (poly_out) is a polynomial that the user wants to print out and has used with
		   an ostream object.
*/
ostream& operator<<(ostream &outstream, const Polynomial &poly_out)
{
    int number_of_terms = poly_out.coefficient.size(),
	    first_term = 0;

	for(int counter_2 = 0; (first_term == 0) && (counter_2 < (number_of_terms + 1)); counter_2++)
	{
		if(poly_out.coefficient[counter_2] != 0)
		{
			first_term = (counter_2 + 1);
		}
	}
    for(int counter = 0; counter < number_of_terms; counter++)
    {
        if(poly_out.coefficient[counter] != 0)
        {
            if(counter == 0)
            {
                outstream << poly_out.coefficient[counter];
            }
            else if(counter == 1)
            {
                if((first_term - 1) != counter)
                {
                    outstream << '+';
                }

				if(poly_out.coefficient[counter] == 1)
                {
                    outstream << 'x';
                }
                else if(poly_out.coefficient[counter] == -1)
                {
                    outstream << '-' << 'x';
                }
                else
                {
                    outstream << poly_out.coefficient[counter] << 'x';
                }
            }
            else
            {
                if((first_term - 1) != counter)
                {
                    outstream << '+';
                }

				if(poly_out.coefficient[counter] == 1)
                {
                    outstream << 'x' << '^' << counter;
                }
                else if(poly_out.coefficient[counter] == -1)
                {
                    outstream << '-' << 'x' << '^' << counter;
                }
                else
                {
                    outstream << poly_out.coefficient[counter] << "x^" << counter;
                }
            }
        }
        else if(poly_out.coefficient[counter] == 0 && (counter == 0) && (poly_out.Is_The_Polynomial_All_Zeroes() == true))
        {
            outstream << poly_out.coefficient[counter];
        }
    }
	return outstream;
}

/**
	Pulls information into polynomial using istream and
	loads up the vector of coefficients in the polynomial
	@return returns an istream operator ready to be used
	        for more I/O
*/
istream& operator>>(istream &instream, Polynomial &poly_in)
{
	int new_value,
	    counter = 0;

	do
	{
		instream >> new_value;

		if(new_value != -1234)
			if(counter != 0)
				poly_in.add_element(new_value);
			else
				poly_in.constant_change(0, new_value);

		counter++;
	} while(new_value != -1234);

	return instream;
}

/**
	Returns a copy of the original polynomial, and after returning,
	makes an iteration of adding 1 onto the polynomial
	@return returns a clone before iterating polynomial
*/
Polynomial Polynomial::operator++(int unused)
{
    Polynomial clone(coefficient);
    coefficient[0] += 1;
    return clone;
}

/**
	Makes an iteration of adding 1 onto the polynomial, then
	returns the polynomial
	@return polynomial after iteration
*/
Polynomial& Polynomial::operator++()
{
    coefficient[0] += 1;
    return (*this);
}

/**	Returns a copy of the original polynomial, and after returning,
	makes an iteration of subtracting 1 onto the polynomial
	@return returns a clone before iterating polynomial
*/
Polynomial Polynomial::operator--(int unused)
{
    Polynomial clone(coefficient);
    coefficient[0] = coefficient[0] - 1;
    return clone;
}

/**
	Makes an iteration of subtracting 1 onto the polynomial, then
	returns the polynomial
	@return polynomial after iteration
*/
Polynomial& Polynomial::operator--()
{
    coefficient[0] = coefficient[0] - 1;
    return (*this);
}

//
// POLYNOMIAL NON-MEMBER FUNCTIONS
//
/**
	This function takes two polynomials and adds their respective coefficients by using a
	for loop until you reach the lower-degree polynomial, and only uses the other polynomial
	from there
	@param the two parameters are the two polynomials you want to add, poly1 and poly2
	@return it returns a third polynomial, resulting_added_polynomial, that was created out
	of the integer vector that stored the added coefficient integers
*/
Polynomial Add(const Polynomial &poly1, const Polynomial &poly2)
{
    int largest_polynomial = 0,
        size_of_poly1 = (poly1.Degree() + 1),
        size_of_poly2 = (poly2.Degree() + 1);

    if(size_of_poly1 > size_of_poly2)
		largest_polynomial = size_of_poly1;
    else
		largest_polynomial = size_of_poly2;


    vector<int> polynomial_size_allocator(largest_polynomial, 0);

    for(int counter = 0; counter < largest_polynomial; counter++)
    {
        if((size_of_poly1 < size_of_poly2) && ((counter + 1) > size_of_poly1))
			polynomial_size_allocator[counter] = poly2.Coefficient(counter);
        else if((size_of_poly2 < size_of_poly1) && ((counter + 1) > size_of_poly2))
			polynomial_size_allocator[counter] = poly1.Coefficient(counter);
        else
			polynomial_size_allocator[counter] = poly1.Coefficient(counter) + poly2.Coefficient(counter);
    }

    Polynomial resulting_added_polynomial(polynomial_size_allocator);
    return resulting_added_polynomial;
}

/**
	This function uses the add function by adding a negative version of the second polynomial
	and returning the "sum"
	@param the parameters are the polynomials objects passed by reference that will be used
	but not changed
	@return the returned value is a new polynomial created by the integer vector resulting by
	the addition of the two polynomials
*/
Polynomial Subtract(const Polynomial &poly1, const Polynomial &poly2)
{
    Polynomial poly2_replacement = poly2;
    poly2_replacement.constantMultiply(-1);
    Polynomial resulting_subtracted_polynomial = Add(poly1,poly2_replacement);
    
    return resulting_subtracted_polynomial;
}

/**
	This function goes through each coefficient of the first polynomial and multiplies each
	coefficient throughout the whole second polynomial using a nested for loop
	@param the parameters are the polynomials objects passed by reference that will be used
	but not changed
	@return the returned value is a new polynomial created by the integer vector resulting by
	the multiplication of the two polynomials
*/
Polynomial Multiply(const Polynomial& poly1, const Polynomial& poly2)
{
    int size_of_poly1 = (poly1.Degree() + 1),
	    size_of_poly2 = (poly2.Degree() + 1);
    vector<int> resulting_polynomial_integers((size_of_poly1 + size_of_poly2), 0);

    for(int counter = 0; counter < size_of_poly2; counter++)
        for(int counter_2 = 0; counter_2 < size_of_poly1; counter_2++)
            resulting_polynomial_integers[counter + counter_2] = resulting_polynomial_integers[counter + counter_2] + (poly1.Coefficient(counter_2) * poly2.Coefficient(counter));

    Polynomial resulting_multiplied_polynomial(resulting_polynomial_integers);

    return resulting_multiplied_polynomial;
}

/**
	Adds using Add(poly1,poly2) function
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored their values
*/
Polynomial operator+(const Polynomial &poly1, const Polynomial &poly2)
{
    Polynomial added_result = Add(poly1, poly2);
    return added_result;
}

/**
	Subtracts using Subtract(poly1,poly2) function
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored their values
*/
Polynomial operator-(const Polynomial &poly1, const Polynomial &poly2)
{
    Polynomial subtracted_result = Subtract(poly1, poly2);
    return subtracted_result;
}

/**
	Multiplies using Multiply(poly1,poly2) function
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored their values
*/
Polynomial operator*(const Polynomial &poly1, const Polynomial &poly2)
{
    return Multiply(poly1, poly2);
}

/**
	Takes a polynomial in by reference and adds another pass-by
	-reference polynomial and adds them using the Add() function
	and iterates the original polynomial that called the function
	(on the left of the += )
	@param the polynomial to be added (on the right of the += )
	@return polynomial after adding
*/
Polynomial& Polynomial::operator+=(const Polynomial &poly_to_be_added)
{
    *this = Add((*this), poly_to_be_added);
    
    return (*this);
}

/**
	Takes a polynomial in by reference and subtracts another pass-by
	-reference polynomial and subtracts them using the Subtract() function
	and iterates the original polynomial that called the function
	(on the left of the -= )
	@param the polynomial to be added (on the right of the -= )
	@return polynomial after subtracting
*/
Polynomial& Polynomial::operator-=(const Polynomial &poly_to_be_subtracted)
{
    Polynomial subtracted_result = (*this - poly_to_be_subtracted);
    *this = subtracted_result;
    return (*this);
}

/**
	Takes a polynomial in by reference and multiplies another pass-by
	-reference polynomial and multiplies them using the Multiply() function
	and iterates the original polynomial that called the function
	(on the left of the *= )
	@param the polynomial to be multiplied (on the right of the *= )
	@return the polynomial after multiplying
*/
Polynomial& Polynomial::operator*=(const Polynomial &poly_to_be_multiplied)
{
    Polynomial multiplied_result = (*this * poly_to_be_multiplied);
    (*this) = multiplied_result;
    return (*this);
}

/**
	Compares two polynomials according to their corresponding coefficients. If they
	are all equal, returns true
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return false or true based on their degrees
*/
bool operator==(const Polynomial &poly1, const Polynomial &poly2)
{
    int size_of_poly1 = (poly1.Degree() + 1),
        size_of_poly2 = (poly2.Degree() + 1);

    if(size_of_poly1 == size_of_poly2)
    {
        for(int counter = 0; counter < size_of_poly1; counter++)
            if(poly1.Coefficient(counter) != poly2.Coefficient(counter))
                return false;
    }
    else
        return false;

    return true;
}

/**
	Compares two polynomials according to the == operator, if == is true, then false
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return false or true based on the value of the == operator
*/
bool operator!=(const Polynomial &poly1, const Polynomial &poly2)
{
	return !(poly1 == poly2);
}

/**
	Compares two polynomials according to the Degree() function
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns true if the degree is lower and false if the degree is not lower
*/
bool operator<(const Polynomial &poly1, const Polynomial &poly2)
{
    int size_of_poly1 = (poly1.Degree() + 1),
        size_of_poly2 = (poly2.Degree() + 1);

    if((size_of_poly1 > size_of_poly2) || (size_of_poly1 == size_of_poly2))
        return false;
    else
        return true;
}

/**
	Compares two polynomials according to the Degree() function
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns true if the degree is higher and false if the degree is not higher
*/
bool operator>(const Polynomial &poly1, const Polynomial &poly2)
{
    return !((poly1 < poly2) || (poly1 == poly2));
}


//
// RATIONAL CONSTRUCTORS
//
/**
	Initializes polynomial px_top to 0 and qx_bottom to 1
*/
Rational::Rational()
{
    px_top.constant_change(0, 0);
    qx_bottom.constant_change(0, 1);
}

/**
	Initializes polynomial px_top to p and qx_bottom to 1
*/
Rational::Rational(const Polynomial &p)
{
    px_top = p;
    qx_bottom.constant_change(0, 1);
}

/**
	Initializes polynomial px_top to px and qx_bottom to qx
*/
Rational::Rational(const Polynomial &px, const Polynomial &qx)
{
    px_top = px;
    qx_bottom = qx;
}

//
// RATIONAL MUTATORS
//
/**
	Changes the polynomial in the px_top spot or the qx_bottom spot depenging
	on what qx_px is. If 1, then top polynomial is changed, if 2 than bottom
	polynomial in rational object is changed
	@param qx_px is a impromptu way of getting the rational to change a certain
		   polynomial
	@param poly_in is the polynomial fed that will be replacing the already
		   constructed polynomial
*/
void Rational::polynomial_Change(int qx_px, const Polynomial &poly_in)
{
	if(qx_px == 1)
		px_top = poly_in;
	else if(qx_px == 2)
		qx_bottom = poly_in;

	return;
}

//
// RATIONAL OTHER
//
/**
	Takes in an x and plugs it into all x in the function
	@return returns the evaluated function
*/
double Rational::evaluateAt(double x)
{
    return (px_top.evaluateAt(x) / qx_bottom.evaluateAt(x));
}


//
// RATIONAL ACCESSORS
//
/**
	Prints out the Rational using the polynomial print function
*/
void Rational::print() const
{
    cout << px_top << " / " << qx_bottom;
    return;
}

/**
	Returns private member px
	@return Returns private member px
*/
Polynomial Rational::return_px() const
{
    return px_top;
}

/**
	Returns private member qx
	@return Returns private member qx
*/
Polynomial Rational::return_qx() const
{
    return qx_bottom;
}

//
// RATIONAL NON-MEMBER FUNCTIONS
//
/**
	Adds using + and * operator for polynomials class
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored their sum
*/
Rational operator+(const Rational &ratl_1, const Rational &ratl_2)
{
    Polynomial top = ((ratl_1.return_px() * ratl_2.return_qx()) + (ratl_2.return_px() * ratl_1.return_qx())),
	           bottom = ratl_1.return_qx() * ratl_2.return_qx();
    Rational added_result(top, bottom);
    return added_result;
}

/**
	Subtracts using - and * operator for polynomials class
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored the difference
*/
Rational operator-(const Rational &ratl_1, const Rational &ratl_2)
{
    Polynomial top = ((ratl_1.return_px() * ratl_2.return_qx()) - (ratl_2.return_px() * ratl_1.return_qx())),
               bottom = ratl_1.return_qx() * ratl_2.return_qx();
    Rational subtracted_result(top,bottom);
    return subtracted_result;
}

/**
	Multiplies using * operator for polynomials class
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored their multiplied total
*/
Rational operator*(const Rational &ratl_1, const Rational &ratl_2)
{
    Polynomial top = (ratl_1.return_px() * ratl_2.return_px()),
               bottom = (ratl_1.return_qx() * ratl_2.return_qx());
    Rational multiplied_result(top, bottom);
    return multiplied_result;
}

/**
	Divides using * operator for polynomials class but multiplies the top by the bottom
	@param one polynomial-by-reference on left, one polynomial-by-reference on right
	@return returns the result of the variable that stored their divided total
*/
Rational operator/(const Rational &ratl_1, const Rational &ratl_2)
{
    Polynomial top = (ratl_1.return_px() * ratl_2.return_qx()),
               bottom = (ratl_1.return_qx() * ratl_2.return_px());
    Rational divided_result(top, bottom);
    return divided_result;
}

//
// RATIONAL MEMBER OPERATOR FUNCTIONS
//
/**
	This operator will be used to return the rational as an ostream object
	via an ostream object
	@return returns the ostream object that called it by reference and
    so another operator/function can be called on it of the user's
    choosing
*/
ostream& operator<<(ostream& outstream, const Rational &rational1)
{
	outstream << rational1.px_top << " / " << rational1.qx_bottom;
	return outstream;
}

/**
	This operator will be used to input the rational from a host file
	via an istream object
	@return returns the istream object that called it by reference and
    so another operator/function can be called on it of the user's
    choosing
*/
istream& operator>>(istream &instream, Rational &rational1)
{
	instream >> rational1.px_top;
	instream.ignore();
	instream >> rational1.qx_bottom;
	return instream;
}

/**
	Takes a rational in by reference and adds another pass-by
	-reference rational and adds them using the + operator function
	and iterates the original rational that called the function
	(on the left of the += )
	@param the rational to be added (on the right of the += )
	@return rational returned after adding
*/
Rational& Rational::operator+=(const Rational &rational_to_be_added)
{
    *this = (*this + rational_to_be_added);
    
    return (*this);
}

/**
	Takes a rational in by reference and subtracts another pass-by
	-reference rational and subtracts them using the - operator function
	and iterates the original rational that called the function
	(on the left of the -= )
	@param the rational to be subtracted (on the right of the += )
	@return rational returned after subtracting
*/
Rational& Rational::operator-=(const Rational &rational_to_be_subtracted)
{
    Rational subtracted_result = (*this - rational_to_be_subtracted);
    *this = subtracted_result;
    return (*this);
}

/**
	Takes a rational in by reference and multiplies another pass-by
	-reference rational using the * operator function and iterates
    the original rational that called the function (on the left of
    the *= ) before returning
	@param the rational to be multiplied (on the right of the *= )
	@return rational returned after multiplying
*/
Rational& Rational::operator*=(const Rational &rational_to_be_multiplied)
{
    Rational multiplied_result = (*this * rational_to_be_multiplied);
    (*this) = multiplied_result;
    return (*this);
}

/**
	Takes a rational in by reference and multiplies another pass-by
	-reference rational using the * operator except it switches the
    top px_top with the qx_bottom in order to function and iterates
    the original rational that called the function (on the left of
    the *= ) before returning
	@param the rational to be "divided" (on the right of the /= )
	@return rational returned after dividing
*/
Rational& Rational::operator/=(const Rational &rational_to_be_divided)
{
    Rational divided_result = (*this / rational_to_be_divided);
    (*this) = divided_result;
    return (*this);
}

/**
	Makes an iteration of adding 1 onto the Rational, then
	returns the original cloned rational
	@return clone of oritinal Rational
*/
Rational Rational::operator++(int unused)
{
    Rational clone(px_top,qx_bottom);
    px_top += qx_bottom;
    return clone;
}

/**
	Makes an iteration of adding 1 from the Rational, then
	returns the polynomial
	@return polynomial after iteration
*/
Rational& Rational::operator++()
{
    px_top += qx_bottom;
    return (*this);
}

/**
	Makes an iteration of adding 1 onto the Rational, then
	returns the original cloned rational
	@return clone of oritinal Rational
*/
Rational Rational::operator--(int unused)
{
    Rational clone(px_top,qx_bottom);
    px_top -= qx_bottom;
    return clone;
}

/**
	Makes an iteration of subtracting 1 from the Rational, then
	returns the polynomial
	@return polynomial after iteration
*/
Rational& Rational::operator--()
{
    px_top -= qx_bottom;
    return (*this);
}


int main()
{
    Polynomial px, qx;
    cout << "Welcome! Please input the coefficients of the first polynomial, p." << endl
		 << "When you are finished, enter -1234." << endl;
	cin >> px;

    cout << endl << "Your first polynomial is p(x) = ";
    px.print();

    cout << endl << endl << "Please input the coefficients of the second polynomial, q." << endl
		 << "When you are finished, enter -1234." << endl;
    cin >> qx;

    cout << endl << "Your second polynomial is q(x) = ";
    qx.print();


    Polynomial numerator, denominator;
    cout << endl << endl << "Please enter coefficients for the numerator and denominator, separated by -1234." << endl;
    cin >> numerator;
    cin >> denominator;
    Rational rx(numerator, denominator);
    cout << "Your rational function is r(x) = ";
    rx.print();

    cout << endl << "Creating file ... ";
	ofstream output;
	output.open("genhen.txt");

    output << "p(x) = " << px << endl
           << "q(x) = " << qx << endl
           << "r(x) = " << rx << endl << endl
           << "p(x)+q(x) = " << (px + qx) << endl
           << "p(x)-q(x) = " << (px - qx) << endl
           << "p(x)*q(x) = " << (px * qx) << endl
           << "p(x)/q(x) = " << px << " / " << qx << endl << endl
           << "r(x)*p(x) = " << (rx * Rational(px)) << endl
           << "r(x)/q(x) = " << (rx / Rational(qx)) << endl
           << "r(x)*p(x)/q(x) = " << (rx * Rational(px,qx));

    output.close();
    cout << "Done." << endl;

    return 0;
}
